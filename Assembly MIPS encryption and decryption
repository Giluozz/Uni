#progetto architteture

.globl main
	
.data
	INmsg:				.asciiz	"input.txt"
	cryptMsg:			.asciiz	"messaggioCriptato.txt"
	decryptMsg: 	.asciiz "messaggioDecriptato.txt"
	theKey:				.asciiz "chiave.txt"

	bufferMsg: 		.space 68096
	bufferTmp: 		.space 68096
	bufferCheck:	.space 128
	bufferKey: 		.space 4

	errorPrompt: 	.asciiz  "The file was not found"

.text


main:
	
	# Apriamo il messaggio da Criptare
											# impostiamo i parametri da passare a openFile (che di fatto sono queeli richiesti dal servizio open file (13)) quindi:
	la $a0, INmsg				# Impostiamo in $a0 l'indirizzo del file da aprire
	jal openFile				# chiamata jal a openFile

	# Leggiamo il messaggio e salviamolo nel buffer

	move $a0, $v0				# Salviamo in $a0 il File Descriptor del nostro messaggio (restituitosci all indirizzo $v0 da openFile)
	la $a1, bufferMsg		# Salviamo l'indirizzo del nostro bufferMsg
	li $a2, 128					# Impostiamo il numero massimo di caratteri da leggere, nel nostro caso tutti
	jal readFile				# chiamata jal a readFile


	# Apriamo la chiave di criptazione
											# impostiamo i parametri da passare a openFile (che di fatto sono queeli richiesti dal servizio open file (13)) quindi:
	la $a0, theKey			# Impostiamo in $a0 l'indirizzo del file da aprire
	jal openFile				# chiamata jal a openFile

	# Leggiamo la chiave e salviamola nel buffer

	move $a0, $v0				# Salviamo in $a0 il File Descriptor della nostra chiave (restituitosci all indirizzo $v0 da openFile)
	la $a1, bufferKey		# Salviamo l'indirizzo del nostro bufferKey
	li $a2, 4						# Impostiamo il numero massimo di caratteri da leggere, nel nostro caso tutti
	jal readFile				# chiamata jal a readFile

	# criptiamo il messaggio

	jal Crypting 				# saltiamo alla label che gestisce la criptazione del nostro messaggio

	# stampiamo il messaggio sul file messaggioCriptato.txt

	la $a0, cryptMsg		# passiamo come argomento a print l'indirizzo del file su stampare
	jal print 					# chiamata jal alla procedure che stampa il messaggio

	# decriptiamo il messaggio

	jal Decrypting 			# saltiamo alla label che gestisce la decriptazione del nostro messaggio

	# stampiamo il messaggio sul file messaggioDecriptato.txt

	la $a0, decryptMsg	# passiamo come argomento a print l'indirizzo del file su stampare
	jal print 					# chiamata jal alla procedura che stampa il messaggio

	j exit							# salto alla label che termina il programma



##########################################################

# Label che si occupa di gestire il ciclo per le chiamate 
# ai vari algoritmi di criptazione

##########################################################

Crypting:
	addi $sp, $sp, -4										# faccio spazio nello stack per inserire l'indirizzo $ra (causa chiamate di procedure annidate)
	sw $ra, 0($sp)											# salvo l'indirizzo di ritorno nello stack
		
	move $s5, $zero

	nextCrypt:	
		lb $t0, bufferKey($s5)						# Carica in $t0 l'elemento del bufferMsg in posizione $t6

		beqz $t0, endCrypt								# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $s5, 4, endCrypt 							# Se l'offset ha valore 4 siamo fuori dal buffer quindi si esce dal ciclo

		beq $t0, 65, iterateForCryptA			# Se l'elemento in $t0 è il codice ascii corrispondente ad A saltiamo a iterateForCryptA
		beq $t0, 66, iterateForCryptB 		# Se l'elemento in $t0 è il codice ascii corrispondente ad B saltiamo a iterateForCryptB
		beq $t0, 67, iterateForCryptC 		# Se l'elemento in $t0 è il codice ascii corrispondente ad C saltiamo a iterateForCryptC
		beq $t0, 69, encryptE 						# Se l'elemento in $t0 è il codice ascii corrispondente ad E saltiamo a encryptE

		jal algorithmD										# Altrimenti saltiamo all'algoritmo D

		returnAfterCrypt:	
			addi $s5, $s5, 1								# incrementiamo $s5 per andare a leggere il carattere successivo nella prossima iterazione
			j nextCrypt											# saltiamo allo statement nextCh per iterare sul b

	endCrypt:
		lw $ra,0($sp)											# carico in $ra il precedente indirizzo di ritorno al chiamante salvato nello stack
		addi $sp,$sp,4										# e ripristino lo stack pointer	

		jr $ra 														# torniamo alla procedura chiamante (main)


#########################################################

# Label che si occupa di gestire il ciclo per le chiamate 
# ai vari algoritmi di decriptazione

#########################################################

Decrypting:
	addi $sp, $sp, -4										# faccio spazio nello stack per inserire l'indirizzo $ra (causa chiamate di procedure annidate)
	sw $ra, 0($sp)											# salvo l'indirizzo di ritorno nello stack

	addi $s5, $s5, -1 									# decrementiamo l'offset $s5 di un byte

	nextDecrypt:	
		lb $t0, bufferKey($s5)						# Carica in $t0 l'elemento del bufferMsg in posizione $t6

		beqz $t0, endDecrypt							# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $s5, -1, endDecrypt 					# Se l'offset ha valore -1 siamo fuori dal buffer quindi si esce dal ciclo

		beq $t0, 65, iterateForDecryptA		# Se l'elemento in $t0 è il codice ascii corrispondente ad A saltiamo a iterateForDecryptA
		beq $t0, 66, iterateForDecryptB		# Se l'elemento in $t0 è il codice ascii corrispondente ad B saltiamo a iterateForDecryptB
		beq $t0, 67, iterateForDecryptC   # Se l'elemento in $t0 è il codice ascii corrispondente ad C saltiamo a iterateForDecryptC
		beq $t0, 69, decryptE 						# Se l'elemento in $t0 è il codice ascii corrispondente ad E saltiamo a decryptE

		jal algorithmD 										# Altrimenti saltiamo all'algoritmo D

		returnAfterDecrypt:	
			addi $s5, $s5, -1								# incrementiamo $s5 per andare a leggere il carattere successivo nella prossima iterazione
			j nextDecrypt										# saltiamo allo statement nextDecrypt per iterare sul buffer

	endDecrypt:	
		lw $ra,0($sp)											# carico in $ra il precedente indirizzo di ritorno al chiamante salvato nello stack
		addi $sp,$sp,4										# e ripristino lo stack pointer	

		jr $ra 														# torniamo alla procedura chiamante (main)



##########################

# Algoritmi di criptazione

##########################

# Algoritmo che gestisce l'iterazione del buffer per A
iterateForCryptA:	
	move $a0, $zero											# impostiamo l'offset da passare come argomento a encryptForABC

	nextCryptA:
		jal encryptForABC									# chiamate jal a encryptForABC

		addi $a0, $a0, 1									# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j nextCryptA											# saltiamo allo statement nextA per iterare sul buffer

			


# Algoritmo che gestisce l'iterazione del buffer per B
iterateForCryptB:	
	move $a0, $zero											# impostiamo l'offset da passare come argomento a encryptForABC
	
	nextCryptB:	
		jal encryptForABC									# chiamate jal a encryptForABC
					

		addi $a0, $a0, 2									# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j nextCryptB											# saltiamo allo statement nextB per iterare sul buffer



# Algoritmo che gestisce l'iterazione del buffer per C
iterateForCryptC:	
	addi $a0, $zero, 1									# impostiamo l'offset da passare come argomento a encryptForABC

	nextCryptC:	
		jal encryptForABC									# chiamate jal a encryptForABC		

		addi $a0, $a0, 2									# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j nextCryptC											# saltiamo allo statement nextC per iterare sul buffer

		
# Algoritmo che gestisce la criptazione dei caratteri per ABC
encryptForABC:

	lb $t0, bufferMsg($a0)							# Carica in $t0 l'elemento del bufferMsg in posizione $t6

	####################################################################################################################

	# When you use lw you load an entire word (4 bytes, not to be confused with words in natural languages), 
	# and that word has to be aligned on a word boundary (the two least significant bits of the address have to be 0).

	# ASCII characters are typically stored using one byte per character, so you should use the lb instruction to load 
	# them instead of lw

	####################################################################################################################

	beqz $t0, endCryptABC 							# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
	beq $a0, 68096, endCryptABC 				# Se l'offset ha valore 68096 siamo fuori dal buffer quindi si salta a endCryptABC
	
	addi $t0, $t0, 4										# Aggiungiamo 4 al codice ASCII
	andi $t0, $t0, 255									# Modulo 256

	####################################################################################################################

	# Never use div for known powers of 2: it's much slower than and for remainder, or right-shift for divide.
	# If b is a power of two, a % b == a & (b - 1). Modulo 256 is even more efficient.

	####################################################################################################################

	sb $t0, bufferMsg($a0)							# Salviamo il nuovo codice ASCII nel bufferMsg

	jr $ra 															# saltiamo all'istruzione successiva a jal nella procedura chiamante per iterare sul buffer

	endCryptABC:	
		j returnAfterCrypt 								# torniamo allo statement returnAfterCrypt della procedura 'Crypting'


# Algoritmo di criptazione E
encryptE:	
	move $s6, $zero											# inizializzamo in $s6 l'offset per il bufferTmp (in cui faremo una copia del messaggio da criptare)
	move $s7, $zero											# inizializzamo in $s7 l'offset per il bufferMsg (in cui salveremo il messaggio criptato)
	move $s4, $zero											# inizializzamo in $s4 l'offset per il bufferCheck (in cui inseriremo i caratteri che sono stati già criptati)

	#########################################

	# facciamo una copia del nostro bufferMsg

	#########################################

	jal copyBuffer											# eseguiamo subito una copia del buffer così da non doverla fare dopo aver criptato il messaggio,
																			# consideranto che il messaggio criptato dall'algoritmo E è più lungo del messaggio da criptare

	la $a0, bufferCheck 								# passiamo l'indirizzo in memoria del bufferCheck all procedura clearBuffer attraverso il registro $a0
	jal clearBuffer 										# salto jal a clearBuffer

	################################################

	# Loop principale dell algoritmo E
	# Le procedure per criptare il messaggio vengono
	# chiamate da qui

	################################################

	nextE:										
		lb $s0, bufferTmp($s6)						# Carica in $s0 l'elemento del bufferTmp in posizione $s6

		beqz $s0, endE										# Se l'elemento in $s0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $s6, 68096, endE 							# Se l'offset ha valore 68096 siamo fuori dal buffer quindi si salta a endE

		move $a0, $s0											# passiamo l'elemento in $s0 come argomento a checkDuplicate

		jal checkDuplicate								# salto jal a checkDuplicate che controlla che il carattere in $s0 non sia gia presente nel bufferMsg
						
		sb $s0, bufferMsg($s7)						# nel caso $s0 non sia già presente nel bufferMsg lo inseriamo
		sb $s0, bufferCheck($s4)					# e lo inseriamo anche nel buffer per il controllo di checkDuplicate
		addi $s4, $s4, 1									# incrementiamo di un byte l'offset $s4
		addi $s7, $s7, 1									# incrementiamo di un byte l'offset $s7

		move $a0, $s0											# passiamo l'elemento in $s0 come argomento a checkDuplicate
		move $a1, $s6											# passiamo l'offset $s6 come argomento a searchEquals attraverso il registro $a1
		move $a2, $s7											# passiamo l'offset $s7 come argomento a searchEquals attraverso il registro $a2

		jal searchEquals									# salto jal a searchEquals che scandisce il buffer per trovare tutte le posizioni del carattere in esame

		move $s7, $v0											# aggiorniamo l'offset $s7 con il nuovo valore restituitoci da searchEquals

	skip:																# label di ritorno da checkDuplicate nel caso il carattere sia già presente nel buffer
		addi $s6, $s6, 1									# incrementiamo $s6 per andare a leggere il carattere successivo nella prossima iterazione
		j nextE														# saltiamo allo statement nextE per iterare sul buffer

	endE:
		addi $s7, $s7, -1									# prima di uscire dall'algoritmo decrementiamo l'offset $s7 di un byte
		sb $zero, bufferMsg($s7)					# per eliminare l'ultimo spazio inserito dalla procedura searchEquals

		j returnAfterCrypt								# torniamo allo statement returnAfterCrypt della procedura chiamante	


	#######################################################

	# checkDuplicate controlla che il carattere in esame 
	# non sia gia presente nel bufferMsg

	# Riceve come argomento il carattere in esame, caricato 
	# in $s0 nel loop principale, e passato in $a0

	#######################################################

	checkDuplicate:		
		move $t7, $zero										# inizializzamo un offset per scandire bufferMsg dall'inizio

		startCheck:
			lb $t0, bufferCheck($t7)				# Carica in $t0 l'elemento del bufferMsg in posizione $t7

			beqz $t0, endCheck							# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
			beq $t7, 128, endCheck 					# Se l'offset ha valore 128 siamo fuori dal buffer quindi si salta a endCheck
			
			beq $a0, $t0, skip							# se $t0 = $a0 (carattere in esame), $a0 è gia nel buffer e si salta a skip

			addi $t7, $t7, 1								# incrementiamo di un byte l'offset $t7
			
			j startCheck										# altrimenti saltiamo allo statement startCheck per iterare sul buffer

		endCheck:		
			jr $ra 													# saltiamo all'istruzione succesiava alla chiamata (nextE)


	##########################################################

	# searchEquals scandisce il buffer per trovare tutte 
	# le posizioni del carattere in esame

	# riceve in ingresso il carattere in esame ($a0), l'offset
	# del bufferTmp ($a1), e l'offset del bufferMsg ($a2)

	##########################################################

	searchEquals:	
		lb $t0, bufferTmp($a1)						# Carica in $t0 l'elemento del bufferMsg in posizione $a1

		beqz $t0, endSearch								# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $a1, 68096, endSearch 				# Se l'offset ha valore 68096 siamo fuori dal buffer quindi si salta a endSearch

		beq $a0, $t0, regPosition					# se $t0 = $a0 (carattere in esame) si si salta a regPosition

		addi $a1, $a1, 1 									# incrementiamo di un byte l'offset $a1
		j searchEquals										# saltiamo allo statement searchEquals per iterare sul buffer

		regPosition:											# regPosition salva nel buffer le posioni del carattere in esame
			addi $t1, $zero, 45							# salviamo in t1 la costante 45 (codice ASCII del carattere '-')
			sb $t1, bufferMsg($a2)					# inseriamo l'elemento $t1 nel bufferMsg	
			addi $a2, $a2, 1								# incrementiamo di un byte l'offset $a2

			addi $sp, $sp, -12		# faccio spazio nello stack per salvare l'indirizzo $ra e gli argomenti di searchEquals
			sw $ra, 8($sp)				# salvo l'indirizzo di ritorno nello stack
			sw $a1, 4($sp) 				# salvo $a1 nello stack
			sw $a0, 0($sp) 				# salvo $a2 nello stack

			move $a0, $a1					# passimo alla procedura intTOascii l'offset del bufferTmp
			move $a1, $a2 				# passimo alla procedura intTOascii l'offset del bufferMsg

			jal intTOascii				# funzione che si occupa di trasformare un intero (la posizione del carattere) in un carattere ascii stampabile

			move $a2, $v0 				# aggiorniamo l'offset del bufferTmp con il nuovo valore restituitoci da intTOascii
			
			lw $a0, 0($sp) 				# ripristino $a0 (carattere in esame)
			lw $a1, 4($sp) 				# ripristino $a1 (offset di bufferTmp)
			lw $ra, 8($sp)				# carico in $ra il precedente indirizzo di ritorno al chiamante salvato nello stack
			addi $sp, $sp, 12			# e ripristino lo stack pointer

			addi $a1, $a1, 1			# incrementiamo di un byte l'offset $a1	
			j searchEquals				# E saltiamo allo statement searchEquals per iterare sul buffer

	endSearch: 	
		addi $t0, $zero, 32					# salviamo in $t0 il codice del carattere ASCII corrispondente allo 'spazio'
		sb $t0, bufferMsg($a2)			# e lo inseriamo nel bufferMsg 
		
		addi $a2, $a2, 1				# incrementiamo di un byte l'offset $a2
		move $v0 , $a2 					# restituiamo al chiamante l'offset del bufferMsg aggiornato
		
		jr $ra 									# saltiamo all'istruzione succesiava alla chiamata (nextE)	


############################

# Algoritmi di decriptazione

############################


# Algoritmo che gestisce l iterazione del buffer per A
iterateForDecryptA:	
	move $a0, $zero					# impostiamo l'offset da passare come argomento a decryptForABC

	nextDecryptA:
		jal decryptForABC			# chiamate jal a decryptForABC

		addi $a0, $a0, 1			# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j nextDecryptA				# saltiamo allo statement nextA per iterare sul buffer

			


# Algoritmo che gestisce l iterazione del buffer per B
iterateForDecryptB:	
	move $a0, $zero					# impostiamo l'offset da passare come argomento a decryptForABC

	nextDecryptB:	
		jal decryptForABC			# chiamate jal a decryptForABC
					

		addi $a0, $a0, 2			# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j nextDecryptB				# saltiamo allo statement nextB per iterare sul buffer



# Algoritmo che gestisce l iterazione del buffer per C
iterateForDecryptC:	
	addi $a0, $zero, 1			# impostiamo l'offset da passare come argomento a decryptForABC

	nextDecryptC:	
		jal decryptForABC			# chiamate jal a decryptForABC		

		addi $a0, $a0, 2			# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j nextDecryptC				# saltiamo allo statement nextC per iterare sul buffer


decryptForABC:

	lb $t0, bufferMsg($a0)			# Carica in $t0 l'elemento del bufferMsg in posizione $t6

	####################################################################################################################

	# When you use lw you load an entire word (4 bytes, not to be confused with words in natural languages), 
	# and that word has to be aligned on a word boundary (the two least significant bits of the address have to be 0).

	# ASCII characters are typically stored using one byte per character, so you should use the lb instruction to load 
	# them instead of lw

	####################################################################################################################

	beqz $t0, endDecryptABC 				# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
	beq $a0, 68096, endDecryptABC 	# Se l'offset ha valore 68096 siamo fuori dal buffer quindi si salta a endDecryptABC
	
	addi $t0, $t0, 256							# aggiungiamo 256
	addi $t0, $t0, -4								# sottraiamo 4 al codice ASCII
	andi $t0, $t0, 255							# Riesegiuamo il modulo 256 per ottenere in codice ASCII originario

	####################################################################################################################

	# Never use div for known powers of 2: it's much slower than and for remainder, or right-shift for divide.
	# If b is a power of two, a % b == a & (b - 1). Modulo 256 is even more efficient.

	####################################################################################################################

	sb $t0, bufferMsg($a0)			# Salviamo il nuovo codice ASCII nel bufferMsg

	jr $ra 											# saltiamo alla procedura chiamante per iterare sul buffer

	endDecryptABC:	
		j returnAfterDecrypt 			# abbiamo finito la decriptazione, torniamo allo statement returnAfterDecrypt della procedura Decrypting




decryptE:
	move $s6, $zero						# inizializzamo in $s6 l'offset per il bufferTmp
	move $s7, $zero						# inizializzamo in $s7 l'offset per il bufferMsg


	#########################################

	# facciamo una copia del nostro bufferMsg

	#########################################

	la $a0, bufferTmp 	  		# passiamo l'indirizzo in memoria del bufferTmp alla procedura clearBuffer attraverso il registro $a0				
	jal clearBuffer 					# salto jal alla procedura clearBuffer

	jal copyBuffer 						# eseguiamo una copia del bufferMsg attraverso la procedura copyBuffer

	la $a0, bufferMsg 				# passiamo l'indirizzo in memoria del bufferTmp all procedura clearBuffer attraverso il registro $a0
	jal clearBuffer 					# salto jal alla procedura clearBuffer

	##################################################

	# Loop principale dell algoritmo E
	# Le procedure per decriptare il messaggio vengono
	# chiamate da qui

	##################################################

	lb $s1, bufferTmp($s6)					# il primo carattere del messaggio criptato è sicuramente un elemento del messaggio decriptato, quindi lo salviamo in $s1
	addi $s6, $s6, 1								# e incrementiamo di un byte l'offset $s6

	nextDecryptE:										
		lb $s0, bufferTmp($s6)				# Carica in $s0 l'elemento del bufferTmp in posizione $s6

		beqz $s0, endDecryptE					# Se l'elemento in $s0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $s6, 68096, endDecryptE 	# Se l'offset ha valore 68096 siamo fuori dal buffer quindi si salta a endDecryptE

		beq $s0, 45, asciiToInt				# Se l'elemento in $s0 è 45 (ovvero il carattere ASCII '-') il prossimo carattere indica la posizione dell'elemento in esame
																	# asciiTOint ha il compito di trasformare una serie di caratteri ascii corrispondenti ad un numero nell'intero corrispondete
		beq $s0, 32, itsChar					# Se l'elemento in $s0 è 32 (ovvero il carattere ASCII 'SPACE') il prossimo carattere indica un elemento del messaggio decriptato

	intReady:												# label di ritorno dalla procedura asciiTOint
		sb $s1, bufferMsg($s7)				# quindi salviamo il carattere in esame (salvato in $s1) nella posizione registrata nel messaggio criptato (ovvero $s7)

		j nextDecryptE								# saltiamo alla label nextDecryptE per iterare sul buffer
		
	itsChar:
		addi $s6, $s6, 1							# incrementiamo di un byte l'offset $s6
		
		lb $s1, bufferTmp($s6)				# e salviamo in $s1 l'elemento che sarà parte del messaggio decriptato

		addi $s6, $s6, 1							# incrementiamo di un byte l'offset $s6

		j nextDecryptE								# saltiamo alla label nextDecryptE per iterare sul buffer

	endDecryptE:
		j returnAfterDecrypt					# abbiamo finito la decriptazione, torniamo allo statement returnAfterDecrypt della procedura invocante (Decrypting)


	################################################################

	# asciiTOint ha il compito di trasformare una serie di caratteri 
	# ascii corrispondenti ad un numero nel'intero corrispondete

	################################################################

	asciiToInt:			
		move $s7, $zero					# salviamo 0 nell offset $s7 del buffer Msg
		move $t4, $zero					# inizializzamo a 0 $t4 (utilizzato per contare quanti caratteri veengono inseriti nello stack)

		addi $t1, $zero, 1				# salviamo la costante 1 in $t1
		addi $t6, $zero, 10				# salviamo la costante 10 in $t6

			
		atiLoop:
			addi $s6, $s6, 1				# incrementiamo l'offset $s6 di bufferTmp

			lb $t0, bufferTmp($s6)	# salviamo in $t0 l'elemento del buffer in posizione $t6, ovvero il primo carattere ascii rappresentante la posizione dell'elemento in $s1

			beq $t0, 45, pop 				# Se l'elemento in $t0 è 45 (ovvero il carattere ASCII '-'') si salta a 'pop'
			beq $t0, 32, pop 				# Se l'elemento in $t0 è 32 (ovvero il carattere ASCII 'SPACE') si salta a 'pop'
			beqz $t0, pop						# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si salta a 'pop'

			addi $t0, $t0, -48 			# sottraiamo 48 (carattere ascii del numero "0") a $t0 per trasformarlo nell' intero corrispondente
			
			addi $sp, $sp, -1 			# facciamo spazio nello Stack
			sb $t0, 0($sp) 					# e salviamo $t0 nello stack
			
			addi $t4, $t4, 1				# incrementiamo quindi $t4 di 1
			
			j atiLoop								# e riiniziamo il ciclo

			pop:
				lb $t0, 0($sp) 			# salviamo in $t0 l'ultimo elemento salvato nello stack
				addi $sp, $sp, 1		# incrementiamo di un byte lo stack pointer

				mult $t0, $t1				# lo moltipichiamo per $t1
				mflo $t0						# e salviamo il risultato in $t0

				add $s7, $s7, $t0		# per poi sommarlo all'offset in $s7

				addi $t4, $t4, -1		# decrementiamo quindi $t4 di 1
				beqz $t4, stopPop		# e se $t4 è uguale a 0 (ovvero non ci sono più elementi da "poppare" dallo stack) usciamo dal ciclo

				mult $t1, $t6				# altrimenti moltiplichiamo $t1 per $t6
				mflo $t1						# e salviamo il risultato in $t1

				j pop 							# saltiamo alla label 'pop' per riiniziare il ciclo

			stopPop:
				j intReady					# arrivati qui il carattere è stato convertito nel corrispettivo intero e salvato nell'offset $s7, saltiamo alla label 'intReady'



###########################################################################

# Algoritmo D
# Considerata la natura di quest'algoritmo, criptazione e decriptazione
# corrispondono
# Ovvero se il primo passaggio dall algoritmo inverte e cripta il messaggio
# il secondo passaggio quindi ri-inverte e decripta

###########################################################################

algorithmD:	
	move $t6, $zero 							# inizializzamo in $t6 l'offset per il bufferMsg

	move $t4, $zero								# Counter degli elementi inseriti nel buffer

	readLoop:	
		lb $t0, bufferMsg($t6)    		# carichiamo il carattere dal nostro bufferMsg
						
		beqz $t0, stringEnd  					# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $t6, 68096, stringEnd
						
		addi $sp, $sp, -1      			# riduciamo lo stack pointer alla posizione successiva
		sb $t0, 0($sp)       				# push del carattere nello Stack

		addi $t4, $t4, 1						# incrementiamo quindi il counter $t4
						
		addi $t6, $t6, 1      			# incrementiamo $t6 per andare a leggere il carattere successivo nella prossima iterazione
		j readLoop									# saltiamo allo statement readLoop per riiniziare il ciclo

	stringEnd:	
		move $t6, $zero							# riinizializzamo $t6

	storeLoop: 	
		lb $t0, 0($sp)							# pop dell'ultimo carattere salvato nello Stack
		addi $sp, $sp, 1      			# incrementiamo lo stack pointer alla posizione precedente
						
		sb $t0, bufferMsg ($t6)			# Salviamo nella prima posizione del nostro buffer l'elemento estratto dallo Stack

		addi $t4, $t4, -1						# decrementiamo quindi il counter $t4
		beqz $t4, endD 							# e se $t4 è 0 non ci sono più elementi da estrarre dallo stack e si esce dal ciclo
						
		addi $t6, $t6, 1						# incrementiamo $t6 per andare alla posizione successiva del buffer
						
		j storeLoop									# saltiamo allo statement storeLoop per riiniziare il ciclo

	endD: 		
		jr $ra 											# torniamo allo procedura chiamante (Cripting o Decripting)



####################################

# Procedure usate dai vari algoritmi

####################################

# procedura che fa una copia del bufferMsg nel bufferTmp

copyBuffer:
	move $t6, $zero								# inizializzamo in $t6 l'offset per i buffer

	copyLoop: 							
		lb $t0, bufferMsg($t6)			# Carica in $t0 l'elemento del bufferMsg in posizione $t6

		beqz $t0, endCopy						# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $t6, 68096, endCopy

		sb $t0, bufferTmp($t6)			# Copiamo l'elemento $t0 nel bufferTmp

		addi $t6, $t6, 1						# incrementiamo $t6 per andare a leggere il carattere successivo nella prossima iterazione
		j copyLoop									# saltiamo allo statement copyLoop per iterare sul buffer

	endCopy:	
		jr $ra 											# torniamo allo procedura chiamante (encryptE o decryptE)



# procedura che pulisce il buffer inserendoci tutti caratteri 'NULL'. 
# Riceve come argomento l'indirizzo in memoria del buffer da stampare

clearBuffer:
	move $t1, $zero								# salviamo in $t1 0 (carattere ASCII 'NULL')	

	clearLoop: 							
		lb $t0, ($a0)								# Carica in $t0 l'elemento del buffer all'indirizzo $a0

		beqz $t0, endClear					# Se l'elemento in $t0 è 0 (ovvero il carattere ASCII 'NULL') si esce dal ciclo
		beq $a0, 68096, endClear

		sb $t1, ($a0)								# Copiamo l'elemento $t1 (carattere 'NULL') nel buffer all'indirizzo $a0

		addi $a0, $a0, 1						# incrementiamo $a0 per andare a leggere il carattere successivo nella prossima iterazione
		j clearLoop									# saltiamo allo statement clearLoop per iterare sul buffer

	endClear:	
		jr $ra 											# torniamo allo procedura chiamante (decryptE)



# procedra che trasforma un intero in una sequenza di caratteri ASCII stampabili
# riceve in ingresso l'offset del bufferTmp ($a0), ovvero la posizione da convertire in ascii, e l'offset al primo spazio vuoto del bufferMsg ($a1)

intTOascii:	
	addi $sp, $sp, -4					# faccio spazio nello stack per inserire l'indirizzo $ra (causa chiamate di procedure annidate)
	sw $ra, 0($sp)						# salvo l'indirizzo di ritorno nello stack

	addi $t1, $zero, 10				# salviamo la costante 10 nel registro $t1

	move $t0, $a0							# facciamo una copia dell'offset $a0 del bufferTmp
	move $t4, $zero						# utilizzo $t4 come contatore dei numeri salvati nello stack
		
	startLoop:

		div $t0, $t1						# dividiamo $t0 (l'offset del bufferTmp) per 10

		mfhi $t0								# salviamo il resto della divisione in $t0

		addi $t0, $t0, 48				# ci sommiamo 48 (codice del carattere ascii "0")

		addi $sp, $sp, -1				# facciamo spazio nello stack
		sb $t0, 0($sp)					# e lo inseriamo nello stack
														# cosi che la sequenza dei resti presa in ordine inverso ci darà il codice ascii corrispondete all'intero in esame
		
		addi $t4, $t4, 1				# incrementiamo quindi $t4 di 1				

		mflo $t0								# salviamo il risultato della divisione in $t0
		
		beqz $t0, endLoop				# e se esso è 0 si esce dal ciclo
		j startLoop							# altrimenti saltiamo a startLoop per riiniziare il ciclo

	endLoop:
		move $a0, $a1 					# passiamo come argomento a stackPop l'offset al primo spazio vuoto del bufferMsg

		jal stackPop						# siamo pronti per tirare fuori dallo stack i resti (in ordine inverso)
				
		lw $ra,0($sp)						# carico in $ra il precedente indirizzo di ritorno al chiamante salvato nello stack
		addi $sp,$sp,4					# e ripristino lo stack pointer

		jr $ra 									# torniamo all'istruzione succesiava alla chiamata (searchEquals)



# procedura che estrae dallo stack i codici inseriti da intTOascii in ordine inverso (grazie alla sua politica LIFO)
# riceve in ingresso l'offset al primo spazio vuoto del bufferMsg ($a0)

stackPop: 								
	
	startPop:		
		lb $t0, 0($sp)					# carichiamo in $t0 l'ultimo elemento inserito nello stack
		addi $sp, $sp, 1				# incrementiamo lo stackpointer di un byte

		sb $t0, bufferMsg($a0)			# altrimenti lo salviamo nel nostro bufferMsg

		addi $a0, $a0, 1				# incrementiamo di un byte l'offset $a0 del bufferMsg

		addi $t4, $t4, -1				# decrementiamo quindi $t4 di 1
		beqz $t4, endPop				# se $t4 è 0 non ci sono più numeri da estrarre e possiamo uscire dal ciclo

		j startPop							# altrimenti riiniziamo il ciclo

	endPop:
		move $v0, $a0 					# restituiamo in $v0 l'offset aggiornato del bufferMsg
		jr $ra 									# torniamo all'istruzione succesiava alla chiamata (intTOascii)


#############################################

# Apertura e salvataggio nell'appostio buffer 
# di un file 

#############################################

# Riceve in ingresso in $a0 l'indirizzo del file da aprire e quindi lo apre

openFile:	
	li $v0, 13				# Carichiamo il servizio open file (13)
	li $a1, 0					# Impostiamo in $a1 la flag per Read-Only (0)
	li $a2, 0					# Ignoramo la modalità
	syscall						# Eseguiamo il servizio
	
	blt	$v0, 0, errorFNF	# File non Trovato, si salta alla label errorFNF

	jr $ra 						# Salto all'istruzione succesiava alla chiamata (main)


# Riceve in ingresso in $a0 il File Descriptor del file da leggere, in $a1 l'indirizzo del nostro buffer dove salvare
# i caratteri letti, e in $a2 il numero massimo di caratteri da leggere

readFile:
	li $v0, 14				# Carichiamo il servizio read from file (14)
	syscall						# Eseguiamo il servizio

	jr $ra 						# Salto all'istruzione succesiava alla chiamata (main)


####################################

# Procedura che termina il programma

####################################

exit:		li $v0, 10				# carichiamo il servizio exit(10)
			syscall							# eseguiamo la syscall per far terminare il programma


##############################################

# Restituisce a schermo un messaggio di errore 
# nel caso il file non venisse trovato

##############################################

errorFNF:	li	$v0, 4				# Carichiamo il servizio Print String (4)
			la	$a0, errorPrompt	# Salviamo in $a0 l'indirizzo del messaggio da stampare
			syscall 							# eseguiamo la syscall


######################################################

# Procedura per stampare il contenuto di bufferMsg
# Riceve in ingresso $a0 in cui è presente l'indirizzo 
# del file txt su cui stampare

######################################################

print:		li $v0, 13					# Carichiamo il servizio open file (13)
  			li $a1, 1            	# Impostiamo in $a1 la flag per poter scrivere sul file (1)
   			li $a2, 0							# Ignoramo la modalità
   			syscall 							# Eseguiamo il servizio

			move $t0, $v0						# Salviamo il File Descriptor in $t0

			li $v0, 15					# Carichiamo il servizio write file (15)
			move $a0, $t0  			# Salviamo in $a0 il File Descriptor della nostro file appena perto
			la $a1, bufferMsg		# Salviamo l'indirizzo del nostro bufferMsg
			li $a2, 68096				# Impostiamo il numero massimo di caratteri da stampare, nel nostro caso tutti quelli disponibili
			syscall 						# Eseguiamo la syscall

			jr $ra
